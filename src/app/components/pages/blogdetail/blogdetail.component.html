<app-header></app-header>
<app-breadcrumb></app-breadcrumb>
<!--====== BLOG SECTION START ======-->
<section class="blog-section pt-120 pb-120">

    <div class="container">
        <div class="row justify-content-center column-reverse">
            <div class="col-lg-8">
                <div class="news-details-box">
                    <div class="entry-content">
                        <!-- <a href="#" class="cat">Businese</a> -->
                        <!-- <pre>
                          <code appPrism prism="let name: string = 'david';" language="typescript"></code>
                        </pre> -->
                        <h2 class="title">DecentraCore: A Full-Stack Blockchain Portfolio — From AMMs & Escrows to Supply Chain & Interoperability </h2>
                        <ul class="post-meta">
                            <li><a href="#" (click)="$event.preventDefault()"><i class="fal fa-user"></i>by EmanCanCode</a></li>
                        </ul>
                        <p class="mb-30">
                          DecentraCore is a full-stack blockchain portfolio that brings together custom automated market makers (constant-product and constant-sum AMMs), event-driven supply-chain tracking, on-chain real-estate escrow contracts and NFT marketplaces, and bridgeless interoperability demos into one cohesive platform. It showcases how smart contracts, off-chain listeners, and a database-driven backend work in concert to power real-time decentralized applications.
                        </p>

                        <div class="gap"></div>
                        <h3 class="subtitle">1. Why DecentraCore’s Key Innovations Matter</h3>
                        <p>
                          DecentraCore shows how to customize every line of swap logic, fee mechanisms, and liquidity models with on-chain AMMs; stream supply-chain events into a database for real-time provenance and transparency; automate escrow flows and NFT-based property transfers through secure on-chain contracts; and teaches bridgeless cross-chain interoperability without a centralized middleman.
                        </p>

                        <div class="gap"></div>
                        <h3 class="subtitle">2. Architecture Overview</h3>
                        <p>
                          DecentraCore is organized into four core systems, each handling a distinct domain of decentralized applications and data flow.
                        </p>
                        <ul class="list-icon">
                          <li><strong>Finance:</strong> Constant-Product AMM &amp; Constant-Sum AMM for token swaps and liquidity provision</li>
                          <li><strong>Supply Chain:</strong> Event-driven provenance tracker that listens to on-chain events and records asset histories</li>
                          <li><strong>Real Estate:</strong> Escrow factory &amp; NFT marketplace managing property tokens and automated settlement</li>
                          <li><strong>Interop &amp; Crypto:</strong> Signature verification and cryptography demos showcasing bridgeless cross-chain flows</li>
                        </ul>

                        <div class="gap"></div>

                        <h3 class="subtitle">3. Data Flow</h3>
                        <ul class="list-icon">
                          <li><strong>User Interaction:</strong> User submits a transaction (swap, add/remove liquidity, escrow action)</li>
                          <li><strong>On-Chain Events:</strong> Smart contract emits events (e.g., Swap, LiquidityAdded, EscrowCreated)</li>
                          <li><strong>Off-Chain Listener:</strong> Node.js service subscribes via WebSocket → captures events → writes to MongoDB</li>
                          <li><strong>API Layer:</strong> Express/TypeScript endpoints query MongoDB and expose RESTful data</li>
                          <li><strong>Front-End Dashboard:</strong> Angular app fetches API data and renders real-time visualizations and code explainers</li>
                        </ul>

                        <div class="gap"></div>
                        <h3 class="subtitle">4.1 Finance: Goals &amp; Invariants</h3>
                        <p>
                          The Finance section focuses on two custom Automated Market Makers:
                          – A <strong>constant-product AMM</strong> (x·y = k) that provides slippage-sensitive pricing and fee accrual for volatile pairs.
                          – A <strong>constant-sum AMM</strong> (linear sum invariant) ideal for near-1:1 swaps (e.g., stablecoins) with a 0.3% fee.
                          Together, they solve the need for flexible, on-chain liquidity protocols that you can fully understand and tweak, rather than rely on black-box deployments.
                        </p>

                        <div class="gap"></div>
                        <h3 class="subtitle">4.2 Finance: Smart Contract Design</h3>
                        <p>
                          Both AMMs expose core functions to swap tokens and manage liquidity, emitting events that off-chain listeners consume (<code>Swapped</code>, <code>AddedLiquidity</code>, <code>RemovedLiquidity</code>).
                        </p>

                        <!-- Constant-Product AMM swap() -->
                        <pre><code appPrism prism="function swap(
  address _tokenReceived,
  uint _amountReceived
) external returns (uint _amountReturned) {
  // only allow tokenA or tokenB
  require(
    _tokenReceived == address(tokenA) || _tokenReceived == address(tokenB),
    'Token not in pair'
  );
  require(_amountReceived > 0, 'Amount must be > 0');

  // select in/out tokens & reserves
  (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) =
    _tokenReceived == address(tokenA)
      ? (tokenA, tokenB, reserveA, reserveB)
      : (tokenB, tokenA, reserveB, reserveA);

  tokenIn.transferFrom(msg.sender, address(this), _amountReceived);

  uint amountInWithFee = (_amountReceived * 997) / 1000; // 0.3% fee
  // dy = (y * dxWithFee) / (x + dxWithFee)
  _amountReturned =
    (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);

  tokenOut.transfer(msg.sender, _amountReturned);
  tokenIn.transfer(owner, _amountReceived - amountInWithFee); // collect fee

  // update internal reserves to match balances
  _update(
    tokenA.balanceOf(address(this)),
    tokenB.balanceOf(address(this))
  );

  emit Swapped(
    msg.sender,
    address(tokenOut),
    _amountReceived,
    _amountReturned
  );
}" language="solidity"></code></pre>

                        <!-- Constant-Sum AMM swap() -->
                        <pre><code appPrism prism="function swap(
  address _tokenReceived,
  uint _amountReceived
) external returns (uint _amountReturned) {
  require(
    _tokenReceived == address(tokenA) || _tokenReceived == address(tokenB),
    'Token not in pair'
  );
  require(_amountReceived > 0, 'Amount > 0');

  // receive tokens & compute 1:1 output minus fee
  if (_tokenReceived == address(tokenA)) {
    tokenA.transferFrom(msg.sender, address(this), _amountReceived);
    _amountReturned = (_amountReceived * 997) / 1000; // fee
    tokenB.transfer(msg.sender, _amountReturned);
    tokenA.transfer(owner, _amountReceived - _amountReturned);
    _update(reserveA + _amountReceived, reserveB - _amountReturned);
  } else {
    tokenB.transferFrom(msg.sender, address(this), _amountReceived);
    _amountReturned = (_amountReceived * 997) / 1000;
    tokenA.transfer(msg.sender, _amountReturned);
    tokenB.transfer(owner, _amountReceived - _amountReturned);
    _update(reserveA - _amountReturned, reserveB + _amountReceived);
  }

  emit Swapped(
    msg.sender,
    _tokenReceived == address(tokenA) ? address(tokenB) : address(tokenA),
    _amountReceived,
    _amountReturned
  );
}" language="solidity"></code></pre>

                        <ul class="list-icon mt-20">
                          <li><strong>Solidity 0.8+</strong> built-in overflow/underflow checks</li>
                          <li>AMMs enforce a 0.5% liquidity-ratio tolerance to prevent price drift on deposits</li>
                        </ul>

                        <div class="gap"></div>
                        <h3 class="subtitle">4.3 Off-Chain Listeners</h3>
                        <p>
                          We run a local Hardhat node exposing a WebSocket RPC, then use Ethers.js listeners to react to <code>Swapped</code> events and forward metrics to MongoDB.
                        </p>

                        <pre><code appPrism prism="// Initialize WebSocket provider
  const provider = new WebSocketProvider(process.env.PROVIDER_URL!.replace(/^https?:\/\//, 'ws://'));

  // Set up and start CPAMM listener
  const cpammListener = new CpammListener(provider);
  await cpammListener.setCpamm(cpammAddress);
  cpammListener.listen(); // logs 'Listening for CPAMM swaps...'

  // In CpammListener.listen():
  this.cpamm.on('Swapped',
    async (sender, tokenReturned, amountReceived, amountReturned) => {
      const fees   = amountReceived.mul(3).div(1000);
      const volume = amountReceived.add(amountReturned);
      await this.mongo.updateFinance(
        'CPAMM',
        toReadableAmount(volume),
        toReadableAmount(fees)
      );
    }
  );" language="typescript"></code></pre>

                        <ul class="list-icon">
                          <li>WebSocketProvider connects to <code>ws://127.0.0.1:8545</code> (or your <code>PROVIDER_URL</code>).</li>
                          <li><code>CpammListener</code> and <code>CsammListener</code> both subscribe to the <code>Swapped</code> event.</li>
                          <li>Each callback computes 0.3% fees and total volume, then calls <code>mongo.updateFinance()</code>.</li>
                          <li>All listeners are managed together in <code>ListenerManager</code> for clean initialization and startup.</li>
                        </ul>

                        <div class="gap"></div>

                        <h3 class="subtitle">4.4 Data Persistence</h3>
                        <p>
                          The MongoDB <code>finance</code> collection holds one document per AMM type (CPAMM, CSAMM), tracking cumulative swaps, volume, and fees.
                        </p>

                        <pre><code appPrism prism="async updateFinance(
  type: FinanceType, // 'CPAMM' | 'CSAMM'
  volumeToAdd: number,
  feesToAdd: number
) {
  const coll = this.db.collection<FinanceDocument>('finance');
  let doc = await coll.findOne({ type });

  if (!doc) {
    // First-ever swap for this AMM
    await coll.insertOne({
      type,
      totalSwaps: 1,
      totalVolume: volumeToAdd,
      totalFees: feesToAdd
    });
    return;
  }

  // Increment aggregates
  doc.totalSwaps++;
  doc.totalVolume += volumeToAdd;
  doc.totalFees   += feesToAdd;

  await coll.findOneAndUpdate({ type }, { $set: doc });
}" language="typescript"></code></pre>

                        <ul class="list-icon">
                          <li>
                            FinanceDocument interface: <br>
                            <pre><code appPrism prism="interface FinanceDocument {
  type: FinanceType; // 'CPAMM' | 'CSAMM'
  totalSwaps: number;
  totalVolume: number;
  totalFees: number;
}" language="typescript"
                            ></code></pre>
                          </li>
                          <li>Creates the document on first swap, then atomically updates aggregates thereafter.</li>
                          <li>Provides a single source of truth for dashboard metrics queried by the backend API.</li>
                        </ul>

                        <div class="gap"></div>
                        <h3 class="subtitle">5.1 Real Estate: Goals &amp; State Machine</h3>
                        <p>
                          The Real Estate module automates traditional escrow flows on-chain for ERC-1155 property tokens. It ensures that a buyer’s earnest deposit, seller/appraiser/inspector approvals, and lender financing are all enforced by the contract’s state machine—moving from <code>Created</code> → <code>Active</code> → <code>Completed</code> or <code>Cancelled</code>—before finally transferring NFT ownership.
                        </p>

                        <div class="gap"></div>

                        <h3 class="subtitle">5.2 Smart Contract Design</h3>
                        <p>
                          Key functions in <code>Escrow</code> manage deposits, approvals, cancellations, and finalization; <code>EscrowFactory</code> handles parameter verification and deployment, emitting <code>EscrowCreated</code> for each new sale.
                        </p>

<!-- Escrow.finalizeSale() -->
<pre>
  <code appPrism prism="function finalizeSale() public reentrancyGuard onlyAuthorized correctState(State.Active) {
    // if financed, lender must cover remainder; otherwise buyer pays full price
    if (lender != address(0)) {
      require(deposit_balance[lender] >= purchase_price - earnest_amount, 'Lender deposit insufficient');
    } else {
      require(deposit_balance[buyer] >= purchase_price, 'Buyer deposit insufficient');
    }

    // calculate and distribute fee (1%) and seller proceeds
    uint256 feeAmount      = (purchase_price * fee) / 100;
    uint256 sellerProceeds = purchase_price - feeAmount;
    state = State.Completed;

    payable(factory).transfer(feeAmount);
    payable(seller).transfer(sellerProceeds);

    // transfer NFT to finance contract or buyer
    address recipient = lender != address(0) ? finance_contract : buyer;
    IERC1155(nft_address).safeTransferFrom(address(this), recipient, nft_id, nft_count, '');

    emit Completed(msg.sender, recipient);
  }" language="solidity"></code>
</pre>

                        <ul class="list-icon">
                          <li><strong>Reentrancy Guard:</strong> Prevents nested calls via <code>locked</code> flag.</li>
                          <li><strong>State Checks:</strong> &nbsp;<code>correctState</code> modifier ensures functions run only in the proper workflow stage.</li>
                          <li><strong>Access Control:</strong> &nbsp;<code>onlyAuthorized</code> restricts actions to seller, buyer, inspector, appraiser, or lender.</li>
                          <li><strong>Factory Pattern:</strong> &nbsp;<code>EscrowFactory</code> verifies parameters &amp; signatures then deploys each <code>Escrow</code>, emitting <code>EscrowCreated</code>.</li>
                        </ul>

                        <div class="gap"></div>
                        <h3 class="subtitle">5.3 Off-Chain Listeners</h3>
                        <p>
                          We subscribe to <code>EscrowCreated</code> events from the factory, write buyer/escrowId pairs to MongoDB, then call <code>setFinanceContract</code> on each new escrow so the lender can later finalize.
                        </p>
<pre>
  <code appPrism prism="// In EscrowFactoryListener.listenForEscrowCreated():
this.escrowFactory.on('EscrowCreated',
  async (escrowAddr, escrowId, buyer, seller, nonce) => {
    // persist buyer & escrowId
    await this.mongo.updateRealEstate({ buyer, escrowId });

    // connect as lender and set finance contract on the new Escrow
    const escrow = await ethers.getContractAt('Escrow', escrowAddr, this.escrowManager);
    await escrow.setFinanceContract(deployLogs.contracts.finance);

    console.log('EscrowCreated:', escrowId, '-> finance set');
  }
);" language="typescript"></code>
</pre>
                        <ul class="list-icon mt-20">
                          <li>WebSocketProvider: Listens at <code>ws://127.0.0.1:8545</code> (or your <code>PROVIDER_URL</code>).</li>
                          <li><code>EscrowFactoryListener</code> ties the <code>EscrowCreated</code> event to database updates and on-chain follow-up calls.</li>
                          <li>Lender credentials (via <code>ESCROW_MANAGER_PRIVATE_KEY</code>) perform the final <code>setFinanceContract()</code> transaction.</li>
                        </ul>
                        <div class="gap"></div>
                        <h3 class="subtitle">5.4 Data Persistence</h3>
                        <p>
                          The <code>realEstate</code> collection holds one document per active sale, storing buyer address and escrowId. When an escrow is completed, that document is removed to reflect final settlement.
                        </p>

                        <pre>
<code appPrism prism="async updateRealEstate(
  data: RealEstateDocument,
  toBeDeleted = false
) {
  const coll = this.db.collection<RealEstateDocument>('realEstate');
  let doc = await coll.findOne({ buyer: data.buyer });

  if (!doc && !toBeDeleted) {
    // first EscrowCreated event
    await coll.insertOne(data);
    return;
  }

  if (doc && toBeDeleted) {
    // sale finalized: remove record
    await coll.deleteOne({ buyer: data.buyer });
  }
}" language="typescript"></code></pre>

                        <ul class="list-icon">
                          <li>
                            RealEstateDocument interface <br>
                            <pre><code appPrism prism="interface FinanceDocument {
  type: FinanceType; // 'CPAMM' | 'CSAMM'
  totalSwaps: number;
  totalVolume: number;
  totalFees: number;
}" language="typescript"
></code></pre>
                          </li>
                          <li><strong>Insert on create:</strong> persists buyer &amp; escrowId when <code>EscrowCreated</code> fires.</li>
                          <li><strong>Delete on finalize:</strong> <code>deleteRealEstateDoc(buyer)</code> removes the document once escrow completes.</li>
                        </ul>

                        <div class="gap"></div>

                        <h3 class="subtitle">6.1 Supply Chain: Goals &amp; Invariants</h3>
                        <p>
                          The Supply Chain module delivers two on-chain process trackers:
                          – A <strong>Provenance</strong> contract that appends product lifecycle events to an immutable array, keyed by a unique byte-encoded ID (creator+nonce).
                          – An <strong>InventoryManagement</strong> contract that registers items, records stock movements, transfers, and enforces reorder thresholds.
                          Both rely on a central <code>AutomatedProcess</code> for escrowed value and use reentrancy guards and nonce-based IDs to guarantee consistency and uniqueness.
                        </p>

                        <div class="gap"></div>
                        <h3 class="subtitle">6.2 Smart Contract Design</h3>
                        <p>
                          Key functions in <code>Provenance</code> record and update product events, while <code>InventoryManagement</code> handles stock updates and transfers. Each emits an event for off-chain listeners.
                        </p>

<!-- Provenance.createRecord() -->
<pre>
  <code appPrism prism="function createRecord(
    string memory _productName,
    string memory _variety,
    string memory _productType,
    uint256 _timestamp,
    string memory _location,
    State _state,
    string memory _additionalInfo
  ) public payable AutomatedProcessSet ReetranyGuard {
    // build record struct
    ProductRecord memory newRecord = ProductRecord({
      productName: _productName,
      variety: _variety,
      productType: _productType,
      timestamp: _timestamp,
      location: bytes(_location),
      state: _state,
      additionalInfo: bytes(_additionalInfo)
    });
    // generate unique ID via creator+nonce
    nonce[msg.sender]++;
    bytes memory id = abi.encodePacked(msg.sender, nonce[msg.sender]);
    productHistory[id].push(newRecord);
    // forward Ether to AutomatedProcess if provided
    if (msg.value > 0) {
      IAutomatedProcess(automatedProcess)
        .setProcessValue{value: msg.value}(nonce[msg.sender], msg.sender);
    }
    emit CreatedRecord(_productName, _variety, _productType, _timestamp, _location, _state, _additionalInfo, msg.sender, msg.value, id);
  }" language="solidity"></code>
</pre>

<!-- InventoryManagement.updateStock() -->
<pre>
  <code appPrism prism="function updateStock(
    uint256 _itemId,
    uint256 _quantity,
    MovementType _movementType,
    string memory _location,
    string memory _note
  ) public onlyRegisteredItem(_itemId) {
    // owner or automatedProcess only
    if (msg.sender != owner) {
      require(msg.sender == automatedProcess, 'Only AutomatedProcess');
    }
    // adjust quantity based on movement type
    if (_movementType == MovementType.Inbound) {
      items[_itemId].quantity += _quantity;
    } else if (_movementType == MovementType.Outbound) {
      require(items[_itemId].quantity >= _quantity, 'Insufficient stock');
      items[_itemId].quantity -= _quantity;
    }
    // log the transaction
    transactions[_itemId].push(InventoryTransaction({
      quantity: _quantity,
      movementType: _movementType,
      timestamp: block.timestamp,
      location: _location,
      note: _note,
      user: msg.sender
    }));
    emit StockUpdated(_itemId, items[_itemId].quantity, _movementType, block.timestamp, _note);
  }" language="solidity"></code>
</pre>
                      <ul class="list-icon">
                        <li><strong>Reentrancy &amp; Access:</strong> <code>ReetranyGuard</code> and <code>onlyRegisteredItem</code>/<code>onlyOwner</code> ensure safe calls.</li>
                        <li><strong>AutomatedProcessSet:</strong> Provenance requires <code>automatedProcess</code> be initialized before creating records.</li>
                        <li><strong>Nonce-ID Scheme:</strong> Guarantees unique <code>productId</code> per creator.</li>
                        <li><strong>Event Emission:</strong> <code>CreatedRecord</code>, <code>UpdatedRecord</code>, <code>StockUpdated</code>, <code>ItemTransferred</code>.</li>
                      </ul>

                      <div class="gap"></div>
                      <h3 class="subtitle">6.3 Off-Chain Listeners</h3>
                      <p>
                        A WebSocketProvider subscribes to on-chain events and updates MongoDB via <code>updateSupplyChain()</code>.
                      </p>

<pre>
  <code appPrism prism="// ProvenanceListener:
this.provenance.on('CreatedRecord', async (..., value, nonce, productId) => {
  await this.mongo.updateSupplyChain({
    type: 'Provenance',
    totalRecords: 1,
    completedRecords: 0,
    totalValueProcessed: toReadableAmount(value)
  });
});

// InventoryManagementListener:
this.inventoryManagement.on('StockUpdated', async (itemId, newQty, movementType) => {
  const isOutbound = movementType === MovementType.Outbound;
  // maybe trigger AutomatedProcess reorders...
  await this.mongo.updateSupplyChain({
    type: 'InventoryManagement',
    totalMovements: 1,
    totalOutbound: isOutbound ? 1 : 0,
    totalReorders: /* boolean reorder ? 1 : 0 */
  });
});" language="typescript"></code>
</pre>

                        <ul class="list-icon">
                          <li>Listens to <code>CreatedRecord</code>, <code>UpdatedRecord</code>, <code>StockUpdated</code>, and <code>ItemTransferred</code> events.</li>
                          <li>Computes metrics (records, completed, volume; movements, outbound, reorders) and calls <code>mongo.updateSupplyChain()</code>.</li>
                          <li>Ensures real-time off-chain visibility into both provenance and inventory flows.</li>
                        </ul>

                        <div class="gap"></div>
                        <h3 class="subtitle">6.4 Data Persistence</h3>
                        <p>
                          The <code>supplyChain</code> collection holds two base documents—<code>InventoryManagement</code> and <code>Provenance</code>—which get incrementally updated.
                        </p>

<pre>
  <code appPrism prism="async updateSupplyChain(data: SupplyChainDocument) {
  const coll = this.db.collection<SupplyChainDocument>('supplyChain');
  const doc  = await coll.findOne({ type: data.type });
  if (!doc) return; // should always exist after init

  if (data.type === 'Provenance') {
    doc.totalRecords        += (data.totalRecords || 0);
    doc.completedRecords    += (data.completedRecords || 0);
    doc.totalValueProcessed += (data.totalValueProcessed || 0);
  } else {
    doc.totalMovements += (data.totalMovements || 0);
    doc.totalOutbound  += (data.totalOutbound || 0);
    doc.totalReorders  += (data.totalReorders || 0);
  }
  await coll.findOneAndUpdate({ type: data.type }, { $set: doc });
}" language="typescript"></code>
</pre>

                      <ul class="list-icon">
                        <li><strong>SupplyChainDocument:</strong>

                        </li>
                        <li>Collection pre-seeded with zeroed documents on <code>initialize()</code>.</li>
                        <li>Each event listener calls <code>updateSupplyChain()</code> to atomically aggregate stats.</li>
                      </ul>
                      <div class="gap"></div>
                      <div class="gap"></div>

                      <h3 class="subtitle">Putting It All Together</h3>
                      <p class="mb-30">
                        Across Finance, Supply Chain, and Real Estate modules, on-chain contracts enforce core logic and state, off-chain listeners capture events over WebSocket, MongoDB aggregates metrics, and an Express/TypeScript API surfaces the data to an Angular dashboard. Picture a user swapping tokens on the CPAMM: the contract emits a Swap event, the listener writes updated volume and fees to MongoDB, and your front-end charts update in real time. Meanwhile, supply-chain events stream provenance and stock movements, and escrow flows manage NFT property sales end-to-end. Each piece plugs seamlessly into the next, delivering the cohesive DecentraCore experience.
                      </p>

                      <div class="gap"></div>

                      <h3 class="subtitle">Lessons Learned &amp; Next Steps</h3>
                      <ul class="list-icon">
                        <li><strong>Strengthen Security:</strong> Integrate OpenZeppelin’s <code>ReentrancyGuard</code> and <code>SafeERC20</code> to harden AMM and escrow contracts.</li>
                        <li><strong>Resilient Event Listeners:</strong> Abstract common subscription patterns (retries, error handling) for more robust off-chain processing.</li>
                        <li><strong>Scalable Architecture:</strong> Consider message queues or streaming platforms (e.g. Kafka) for high-volume event pipelines and analytics.</li>
                        <li><strong>Multi-Chain Deployment:</strong> Deploy AMMs and EscrowFactory on testnets like Goerli, or EVM-compatible chains, using Infura/Alchemy WebSocket endpoints.</li>
                        <li><strong>Enhanced Developer UX:</strong> Add live code sandboxes, interactive demos, and TypeDoc-generated API docs in the Angular blog.</li>
                      </ul>

                      <div class="gap"></div>

                      <h3 class="subtitle">Final Thoughts</h3>
                      <p class="mb-30">
                        Building DecentraCore has been an rewarding journey—from crafting precise invariants in Solidity to wiring up real-time event pipelines and delivering a polished front-end. I hope this deep dive empowers you to build your own end-to-end dApps, understand every layer, and continue pushing the boundaries of decentralization.
                      </p>

                      <div class="row align-items-center">
                        <div class="col-md-5 mb-30">
                          <img src="{{blogauthor}}" alt="EmanCanCode profile">
                        </div>
                        <div class="col-md-7 mb-30">
                          <p>
                            I'm Emmanuel Douge—a full-stack blockchain engineer and USMC veteran. DecentraCore embodies my commitment to transparency, security, and craftsmanship in decentralized applications. I’d love to hear your thoughts or questions—connect at <a href="mailto:emancancode@gmail.com">emancancode&#64;gmail.com</a> or follow me on <a href="https://github.com/EmanCanCode">GitHub</a>.
                          </p>
                        </div>
                      </div>
                    </div>
                    <div class="entry-footer">
                        <div class="tag-and-share mt-50 mb-50 d-md-flex align-items-center justify-content-between">
                            <div class="tag">
                                <h5>Related Tags</h5>
                                <ul>
                                    <li *ngFor="let relatedtag of relatedtags"><a (click)="$event.preventDefault()" href="#">{{relatedtag.tag}}</a></li>
                                </ul>
                            </div>
                            <div class="share text-md-right">
                                <h5>Socials</h5>
                                <ul>
                                    <li *ngFor="let blogsocial of blogsocials"><a target="_blank" href="{{blogsocial.url}}"><i class="fab {{blogsocial.icon}}"></i></a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Blog Sidebar -->
            <div class="col-lg-4 col-md-8 col-sm-10">
                <app-blogsidebar></app-blogsidebar>
            </div>
        </div>
    </div>
</section>
<!--====== BLOG SECTION END ======-->
<!--====== INSTAGRAM FEED PART END ======-->
<app-footerthree></app-footerthree>
